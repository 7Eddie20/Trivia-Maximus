{"ast":null,"code":"import _toConsumableArray from \"R:/Projects/Trivia-Maximus/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { invariant } from 'hey-listen';\nimport { stopAnimation, animateVisualElement } from '../render/utils/animation.mjs';\nimport { setValues } from '../render/utils/setters.mjs';\n\n/**\r\n * @public\r\n */\nfunction animationControls() {\n  /**\r\n   * Track whether the host component has mounted.\r\n   */\n  var hasMounted = false;\n  /**\r\n   * Pending animations that are started before a component is mounted.\r\n   * TODO: Remove this as animations should only run in effects\r\n   */\n  var pendingAnimations = [];\n  /**\r\n   * A collection of linked component animation controls.\r\n   */\n  var subscribers = new Set();\n  var controls = {\n    subscribe: function subscribe(visualElement) {\n      subscribers.add(visualElement);\n      return function () {\n        return void subscribers.delete(visualElement);\n      };\n    },\n    start: function start(definition, transitionOverride) {\n      /**\r\n       * TODO: We only perform this hasMounted check because in Framer we used to\r\n       * encourage the ability to start an animation within the render phase. This\r\n       * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\r\n       * we can ditch this.\r\n       */\n      if (hasMounted) {\n        var animations = [];\n        subscribers.forEach(function (visualElement) {\n          animations.push(animateVisualElement(visualElement, definition, {\n            transitionOverride: transitionOverride\n          }));\n        });\n        return Promise.all(animations);\n      } else {\n        return new Promise(function (resolve) {\n          pendingAnimations.push({\n            animation: [definition, transitionOverride],\n            resolve: resolve\n          });\n        });\n      }\n    },\n    set: function set(definition) {\n      invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      return subscribers.forEach(function (visualElement) {\n        setValues(visualElement, definition);\n      });\n    },\n    stop: function stop() {\n      subscribers.forEach(function (visualElement) {\n        stopAnimation(visualElement);\n      });\n    },\n    mount: function mount() {\n      hasMounted = true;\n      pendingAnimations.forEach(function (_ref) {\n        var animation = _ref.animation,\n          resolve = _ref.resolve;\n        controls.start.apply(controls, _toConsumableArray(animation)).then(resolve);\n      });\n      return function () {\n        hasMounted = false;\n        controls.stop();\n      };\n    }\n  };\n  return controls;\n}\nexport { animationControls };","map":{"version":3,"names":["invariant","stopAnimation","animateVisualElement","setValues","animationControls","hasMounted","pendingAnimations","subscribers","Set","controls","subscribe","visualElement","add","delete","start","definition","transitionOverride","animations","forEach","push","Promise","all","resolve","animation","set","stop","mount","then"],"sources":["R:/Projects/Trivia-Maximus/node_modules/framer-motion/dist/es/animation/animation-controls.mjs"],"sourcesContent":["import { invariant } from 'hey-listen';\r\nimport { stopAnimation, animateVisualElement } from '../render/utils/animation.mjs';\r\nimport { setValues } from '../render/utils/setters.mjs';\r\n\r\n/**\r\n * @public\r\n */\r\nfunction animationControls() {\r\n    /**\r\n     * Track whether the host component has mounted.\r\n     */\r\n    let hasMounted = false;\r\n    /**\r\n     * Pending animations that are started before a component is mounted.\r\n     * TODO: Remove this as animations should only run in effects\r\n     */\r\n    const pendingAnimations = [];\r\n    /**\r\n     * A collection of linked component animation controls.\r\n     */\r\n    const subscribers = new Set();\r\n    const controls = {\r\n        subscribe(visualElement) {\r\n            subscribers.add(visualElement);\r\n            return () => void subscribers.delete(visualElement);\r\n        },\r\n        start(definition, transitionOverride) {\r\n            /**\r\n             * TODO: We only perform this hasMounted check because in Framer we used to\r\n             * encourage the ability to start an animation within the render phase. This\r\n             * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\r\n             * we can ditch this.\r\n             */\r\n            if (hasMounted) {\r\n                const animations = [];\r\n                subscribers.forEach((visualElement) => {\r\n                    animations.push(animateVisualElement(visualElement, definition, {\r\n                        transitionOverride,\r\n                    }));\r\n                });\r\n                return Promise.all(animations);\r\n            }\r\n            else {\r\n                return new Promise((resolve) => {\r\n                    pendingAnimations.push({\r\n                        animation: [definition, transitionOverride],\r\n                        resolve,\r\n                    });\r\n                });\r\n            }\r\n        },\r\n        set(definition) {\r\n            invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\r\n            return subscribers.forEach((visualElement) => {\r\n                setValues(visualElement, definition);\r\n            });\r\n        },\r\n        stop() {\r\n            subscribers.forEach((visualElement) => {\r\n                stopAnimation(visualElement);\r\n            });\r\n        },\r\n        mount() {\r\n            hasMounted = true;\r\n            pendingAnimations.forEach(({ animation, resolve }) => {\r\n                controls.start(...animation).then(resolve);\r\n            });\r\n            return () => {\r\n                hasMounted = false;\r\n                controls.stop();\r\n            };\r\n        },\r\n    };\r\n    return controls;\r\n}\r\n\r\nexport { animationControls };\r\n"],"mappings":";AAAA,SAASA,SAAS,QAAQ,YAAY;AACtC,SAASC,aAAa,EAAEC,oBAAoB,QAAQ,+BAA+B;AACnF,SAASC,SAAS,QAAQ,6BAA6B;;AAEvD;AACA;AACA;AACA,SAASC,iBAAiB,GAAG;EACzB;AACJ;AACA;EACI,IAAIC,UAAU,GAAG,KAAK;EACtB;AACJ;AACA;AACA;EACI,IAAMC,iBAAiB,GAAG,EAAE;EAC5B;AACJ;AACA;EACI,IAAMC,WAAW,GAAG,IAAIC,GAAG,EAAE;EAC7B,IAAMC,QAAQ,GAAG;IACbC,SAAS,qBAACC,aAAa,EAAE;MACrBJ,WAAW,CAACK,GAAG,CAACD,aAAa,CAAC;MAC9B,OAAO;QAAA,OAAM,KAAKJ,WAAW,CAACM,MAAM,CAACF,aAAa,CAAC;MAAA;IACvD,CAAC;IACDG,KAAK,iBAACC,UAAU,EAAEC,kBAAkB,EAAE;MAClC;AACZ;AACA;AACA;AACA;AACA;MACY,IAAIX,UAAU,EAAE;QACZ,IAAMY,UAAU,GAAG,EAAE;QACrBV,WAAW,CAACW,OAAO,CAAC,UAACP,aAAa,EAAK;UACnCM,UAAU,CAACE,IAAI,CAACjB,oBAAoB,CAACS,aAAa,EAAEI,UAAU,EAAE;YAC5DC,kBAAkB,EAAlBA;UACJ,CAAC,CAAC,CAAC;QACP,CAAC,CAAC;QACF,OAAOI,OAAO,CAACC,GAAG,CAACJ,UAAU,CAAC;MAClC,CAAC,MACI;QACD,OAAO,IAAIG,OAAO,CAAC,UAACE,OAAO,EAAK;UAC5BhB,iBAAiB,CAACa,IAAI,CAAC;YACnBI,SAAS,EAAE,CAACR,UAAU,EAAEC,kBAAkB,CAAC;YAC3CM,OAAO,EAAPA;UACJ,CAAC,CAAC;QACN,CAAC,CAAC;MACN;IACJ,CAAC;IACDE,GAAG,eAACT,UAAU,EAAE;MACZf,SAAS,CAACK,UAAU,EAAE,+GAA+G,CAAC;MACtI,OAAOE,WAAW,CAACW,OAAO,CAAC,UAACP,aAAa,EAAK;QAC1CR,SAAS,CAACQ,aAAa,EAAEI,UAAU,CAAC;MACxC,CAAC,CAAC;IACN,CAAC;IACDU,IAAI,kBAAG;MACHlB,WAAW,CAACW,OAAO,CAAC,UAACP,aAAa,EAAK;QACnCV,aAAa,CAACU,aAAa,CAAC;MAChC,CAAC,CAAC;IACN,CAAC;IACDe,KAAK,mBAAG;MACJrB,UAAU,GAAG,IAAI;MACjBC,iBAAiB,CAACY,OAAO,CAAC,gBAA4B;QAAA,IAAzBK,SAAS,QAATA,SAAS;UAAED,OAAO,QAAPA,OAAO;QAC3Cb,QAAQ,CAACK,KAAK,OAAdL,QAAQ,qBAAUc,SAAS,EAAC,CAACI,IAAI,CAACL,OAAO,CAAC;MAC9C,CAAC,CAAC;MACF,OAAO,YAAM;QACTjB,UAAU,GAAG,KAAK;QAClBI,QAAQ,CAACgB,IAAI,EAAE;MACnB,CAAC;IACL;EACJ,CAAC;EACD,OAAOhB,QAAQ;AACnB;AAEA,SAASL,iBAAiB"},"metadata":{},"sourceType":"module","externalDependencies":[]}