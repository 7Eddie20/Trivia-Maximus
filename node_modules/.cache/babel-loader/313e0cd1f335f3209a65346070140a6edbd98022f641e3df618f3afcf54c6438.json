{"ast":null,"code":"import _toConsumableArray from \"R:/Projects/Trivia-Maximus/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"R:/Projects/Trivia-Maximus/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"R:/Projects/Trivia-Maximus/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\", \"repeat\", \"repeatType\", \"repeatDelay\", \"from\"],\n  _excluded2 = [\"ease\", \"times\", \"yoyo\", \"flip\", \"loop\"];\nimport { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { isEasingArray, easingDefinitionToFunction } from './easing.mjs';\nimport { isAnimatable } from './is-animatable.mjs';\nimport { getDefaultTransition } from './default-transitions.mjs';\nimport { warning } from 'hey-listen';\nimport { getAnimatableNone } from '../../render/dom/value-types/animatable-none.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { resolveFinalValueInKeyframes } from '../../utils/resolve-value.mjs';\nimport { delay } from '../../utils/delay.mjs';\nimport { inertia } from '../legacy-popmotion/inertia.mjs';\nimport { animate } from '../legacy-popmotion/index.mjs';\n\n/**\r\n * Decide whether a transition is defined on a given Transition.\r\n * This filters out orchestration options and returns true\r\n * if any options are left.\r\n */\nfunction isTransitionDefined(_ref) {\n  var when = _ref.when,\n    _delay = _ref.delay,\n    delayChildren = _ref.delayChildren,\n    staggerChildren = _ref.staggerChildren,\n    staggerDirection = _ref.staggerDirection,\n    repeat = _ref.repeat,\n    repeatType = _ref.repeatType,\n    repeatDelay = _ref.repeatDelay,\n    from = _ref.from,\n    transition = _objectWithoutProperties(_ref, _excluded);\n  return !!Object.keys(transition).length;\n}\nvar legacyRepeatWarning = false;\n/**\r\n * Convert Framer Motion's Transition type into Popmotion-compatible options.\r\n */\nfunction convertTransitionToAnimationOptions(_ref2) {\n  var ease = _ref2.ease,\n    times = _ref2.times,\n    yoyo = _ref2.yoyo,\n    flip = _ref2.flip,\n    loop = _ref2.loop,\n    transition = _objectWithoutProperties(_ref2, _excluded2);\n  var options = _objectSpread({}, transition);\n  if (times) options[\"offset\"] = times;\n  /**\r\n   * Convert any existing durations from seconds to milliseconds\r\n   */\n  if (transition.duration) options[\"duration\"] = secondsToMilliseconds(transition.duration);\n  if (transition.repeatDelay) options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n  /**\r\n   * Map easing names to Popmotion's easing functions\r\n   */\n  if (ease) {\n    options[\"ease\"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);\n  }\n  /**\r\n   * Support legacy transition API\r\n   */\n  if (transition.type === \"tween\") options.type = \"keyframes\";\n  /**\r\n   * TODO: These options are officially removed from the API.\r\n   */\n  if (yoyo || loop || flip) {\n    warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n    legacyRepeatWarning = true;\n    if (yoyo) {\n      options.repeatType = \"reverse\";\n    } else if (loop) {\n      options.repeatType = \"loop\";\n    } else if (flip) {\n      options.repeatType = \"mirror\";\n    }\n    options.repeat = loop || yoyo || flip || transition.repeat;\n  }\n  /**\r\n   * TODO: Popmotion 9 has the ability to automatically detect whether to use\r\n   * a keyframes or spring animation, but does so by detecting velocity and other spring options.\r\n   * It'd be good to introduce a similar thing here.\r\n   */\n  if (transition.type !== \"spring\") options.type = \"keyframes\";\n  return options;\n}\n/**\r\n * Get the delay for a value by checking Transition with decreasing specificity.\r\n */\nfunction getDelayFromTransition(transition, key) {\n  var _a, _b;\n  var valueTransition = getValueTransition(transition, key) || {};\n  return (_b = (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : transition.delay) !== null && _b !== void 0 ? _b : 0;\n}\nfunction hydrateKeyframes(options) {\n  if (Array.isArray(options.to) && options.to[0] === null) {\n    options.to = _toConsumableArray(options.to);\n    options.to[0] = options.from;\n  }\n  return options;\n}\nfunction getPopmotionAnimationOptions(transition, options, key) {\n  if (Array.isArray(options.to) && transition.duration === undefined) {\n    transition.duration = 0.8;\n  }\n  hydrateKeyframes(options);\n  /**\r\n   * Get a default transition if none is determined to be defined.\r\n   */\n  if (!isTransitionDefined(transition)) {\n    transition = _objectSpread(_objectSpread({}, transition), getDefaultTransition(key, options.to));\n  }\n  return _objectSpread(_objectSpread({}, options), convertTransitionToAnimationOptions(transition));\n}\n/**\r\n *\r\n */\nfunction getAnimation(key, value, target, transition, onComplete) {\n  var valueTransition = getValueTransition(transition, key) || {};\n  var origin = valueTransition.from !== undefined ? valueTransition.from : value.get();\n  var isTargetAnimatable = isAnimatable(key, target);\n  if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n    /**\r\n     * If we're trying to animate from \"none\", try and get an animatable version\r\n     * of the target. This could be improved to work both ways.\r\n     */\n    origin = getAnimatableNone(key, target);\n  } else if (isZero(origin) && typeof target === \"string\") {\n    origin = getZeroUnit(target);\n  } else if (!Array.isArray(target) && isZero(target) && typeof origin === \"string\") {\n    target = getZeroUnit(origin);\n  }\n  var isOriginAnimatable = isAnimatable(key, origin);\n  warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \".concat(key, \" from \\\"\").concat(origin, \"\\\" to \\\"\").concat(target, \"\\\". \").concat(origin, \" is not an animatable value - to enable this animation set \").concat(origin, \" to a value animatable to \").concat(target, \" via the `style` property.\"));\n  function start() {\n    var options = {\n      from: origin,\n      to: target,\n      velocity: value.getVelocity(),\n      onComplete: onComplete,\n      onUpdate: function onUpdate(v) {\n        return value.set(v);\n      }\n    };\n    return valueTransition.type === \"inertia\" || valueTransition.type === \"decay\" ? inertia(_objectSpread(_objectSpread({}, options), valueTransition)) : animate(_objectSpread(_objectSpread({}, getPopmotionAnimationOptions(valueTransition, options, key)), {}, {\n      onUpdate: function onUpdate(v) {\n        options.onUpdate(v);\n        valueTransition.onUpdate && valueTransition.onUpdate(v);\n      },\n      onComplete: function onComplete() {\n        options.onComplete();\n        valueTransition.onComplete && valueTransition.onComplete();\n      }\n    }));\n  }\n  function set() {\n    var finalTarget = resolveFinalValueInKeyframes(target);\n    value.set(finalTarget);\n    onComplete();\n    valueTransition.onUpdate && valueTransition.onUpdate(finalTarget);\n    valueTransition.onComplete && valueTransition.onComplete();\n    return {\n      stop: function stop() {}\n    };\n  }\n  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;\n}\nfunction isZero(value) {\n  return value === 0 || typeof value === \"string\" && parseFloat(value) === 0 && value.indexOf(\" \") === -1;\n}\nfunction getZeroUnit(potentialUnitType) {\n  return typeof potentialUnitType === \"number\" ? 0 : getAnimatableNone(\"\", potentialUnitType);\n}\nfunction getValueTransition(transition, key) {\n  return transition[key] || transition[\"default\"] || transition;\n}\n/**\r\n * Start animation on a MotionValue. This function is an interface between\r\n * Framer Motion and Popmotion\r\n */\nfunction startAnimation(key, value, target) {\n  var transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  if (instantAnimationState.current) {\n    transition = {\n      type: false\n    };\n  }\n  return value.start(function (onComplete) {\n    var controls;\n    var animation = getAnimation(key, value, target, transition, onComplete);\n    var delayBy = getDelayFromTransition(transition, key);\n    var start = function start() {\n      return controls = animation();\n    };\n    var cancelDelay;\n    if (delayBy) {\n      cancelDelay = delay(start, secondsToMilliseconds(delayBy));\n    } else {\n      start();\n    }\n    return function () {\n      cancelDelay && cancelDelay();\n      controls && controls.stop();\n    };\n  });\n}\nexport { convertTransitionToAnimationOptions, getDelayFromTransition, getPopmotionAnimationOptions, getValueTransition, getZeroUnit, hydrateKeyframes, isTransitionDefined, isZero, startAnimation };","map":{"version":3,"names":["secondsToMilliseconds","isEasingArray","easingDefinitionToFunction","isAnimatable","getDefaultTransition","warning","getAnimatableNone","instantAnimationState","resolveFinalValueInKeyframes","delay","inertia","animate","isTransitionDefined","when","_delay","delayChildren","staggerChildren","staggerDirection","repeat","repeatType","repeatDelay","from","transition","Object","keys","length","legacyRepeatWarning","convertTransitionToAnimationOptions","ease","times","yoyo","flip","loop","options","duration","map","type","getDelayFromTransition","key","_a","_b","valueTransition","getValueTransition","hydrateKeyframes","Array","isArray","to","getPopmotionAnimationOptions","undefined","getAnimation","value","target","onComplete","origin","get","isTargetAnimatable","isZero","getZeroUnit","isOriginAnimatable","start","velocity","getVelocity","onUpdate","v","set","finalTarget","stop","parseFloat","indexOf","potentialUnitType","startAnimation","current","controls","animation","delayBy","cancelDelay"],"sources":["R:/Projects/Trivia-Maximus/node_modules/framer-motion/dist/es/animation/utils/transitions.mjs"],"sourcesContent":["import { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\r\nimport { isEasingArray, easingDefinitionToFunction } from './easing.mjs';\r\nimport { isAnimatable } from './is-animatable.mjs';\r\nimport { getDefaultTransition } from './default-transitions.mjs';\r\nimport { warning } from 'hey-listen';\r\nimport { getAnimatableNone } from '../../render/dom/value-types/animatable-none.mjs';\r\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\r\nimport { resolveFinalValueInKeyframes } from '../../utils/resolve-value.mjs';\r\nimport { delay } from '../../utils/delay.mjs';\r\nimport { inertia } from '../legacy-popmotion/inertia.mjs';\r\nimport { animate } from '../legacy-popmotion/index.mjs';\r\n\r\n/**\r\n * Decide whether a transition is defined on a given Transition.\r\n * This filters out orchestration options and returns true\r\n * if any options are left.\r\n */\r\nfunction isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, ...transition }) {\r\n    return !!Object.keys(transition).length;\r\n}\r\nlet legacyRepeatWarning = false;\r\n/**\r\n * Convert Framer Motion's Transition type into Popmotion-compatible options.\r\n */\r\nfunction convertTransitionToAnimationOptions({ ease, times, yoyo, flip, loop, ...transition }) {\r\n    const options = { ...transition };\r\n    if (times)\r\n        options[\"offset\"] = times;\r\n    /**\r\n     * Convert any existing durations from seconds to milliseconds\r\n     */\r\n    if (transition.duration)\r\n        options[\"duration\"] = secondsToMilliseconds(transition.duration);\r\n    if (transition.repeatDelay)\r\n        options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\r\n    /**\r\n     * Map easing names to Popmotion's easing functions\r\n     */\r\n    if (ease) {\r\n        options[\"ease\"] = isEasingArray(ease)\r\n            ? ease.map(easingDefinitionToFunction)\r\n            : easingDefinitionToFunction(ease);\r\n    }\r\n    /**\r\n     * Support legacy transition API\r\n     */\r\n    if (transition.type === \"tween\")\r\n        options.type = \"keyframes\";\r\n    /**\r\n     * TODO: These options are officially removed from the API.\r\n     */\r\n    if (yoyo || loop || flip) {\r\n        warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\r\n        legacyRepeatWarning = true;\r\n        if (yoyo) {\r\n            options.repeatType = \"reverse\";\r\n        }\r\n        else if (loop) {\r\n            options.repeatType = \"loop\";\r\n        }\r\n        else if (flip) {\r\n            options.repeatType = \"mirror\";\r\n        }\r\n        options.repeat = loop || yoyo || flip || transition.repeat;\r\n    }\r\n    /**\r\n     * TODO: Popmotion 9 has the ability to automatically detect whether to use\r\n     * a keyframes or spring animation, but does so by detecting velocity and other spring options.\r\n     * It'd be good to introduce a similar thing here.\r\n     */\r\n    if (transition.type !== \"spring\")\r\n        options.type = \"keyframes\";\r\n    return options;\r\n}\r\n/**\r\n * Get the delay for a value by checking Transition with decreasing specificity.\r\n */\r\nfunction getDelayFromTransition(transition, key) {\r\n    var _a, _b;\r\n    const valueTransition = getValueTransition(transition, key) || {};\r\n    return (_b = (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : transition.delay) !== null && _b !== void 0 ? _b : 0;\r\n}\r\nfunction hydrateKeyframes(options) {\r\n    if (Array.isArray(options.to) && options.to[0] === null) {\r\n        options.to = [...options.to];\r\n        options.to[0] = options.from;\r\n    }\r\n    return options;\r\n}\r\nfunction getPopmotionAnimationOptions(transition, options, key) {\r\n    if (Array.isArray(options.to) && transition.duration === undefined) {\r\n        transition.duration = 0.8;\r\n    }\r\n    hydrateKeyframes(options);\r\n    /**\r\n     * Get a default transition if none is determined to be defined.\r\n     */\r\n    if (!isTransitionDefined(transition)) {\r\n        transition = {\r\n            ...transition,\r\n            ...getDefaultTransition(key, options.to),\r\n        };\r\n    }\r\n    return {\r\n        ...options,\r\n        ...convertTransitionToAnimationOptions(transition),\r\n    };\r\n}\r\n/**\r\n *\r\n */\r\nfunction getAnimation(key, value, target, transition, onComplete) {\r\n    const valueTransition = getValueTransition(transition, key) || {};\r\n    let origin = valueTransition.from !== undefined ? valueTransition.from : value.get();\r\n    const isTargetAnimatable = isAnimatable(key, target);\r\n    if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\r\n        /**\r\n         * If we're trying to animate from \"none\", try and get an animatable version\r\n         * of the target. This could be improved to work both ways.\r\n         */\r\n        origin = getAnimatableNone(key, target);\r\n    }\r\n    else if (isZero(origin) && typeof target === \"string\") {\r\n        origin = getZeroUnit(target);\r\n    }\r\n    else if (!Array.isArray(target) &&\r\n        isZero(target) &&\r\n        typeof origin === \"string\") {\r\n        target = getZeroUnit(origin);\r\n    }\r\n    const isOriginAnimatable = isAnimatable(key, origin);\r\n    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${key} from \"${origin}\" to \"${target}\". ${origin} is not an animatable value - to enable this animation set ${origin} to a value animatable to ${target} via the \\`style\\` property.`);\r\n    function start() {\r\n        const options = {\r\n            from: origin,\r\n            to: target,\r\n            velocity: value.getVelocity(),\r\n            onComplete,\r\n            onUpdate: (v) => value.set(v),\r\n        };\r\n        return valueTransition.type === \"inertia\" ||\r\n            valueTransition.type === \"decay\"\r\n            ? inertia({ ...options, ...valueTransition })\r\n            : animate({\r\n                ...getPopmotionAnimationOptions(valueTransition, options, key),\r\n                onUpdate: (v) => {\r\n                    options.onUpdate(v);\r\n                    valueTransition.onUpdate && valueTransition.onUpdate(v);\r\n                },\r\n                onComplete: () => {\r\n                    options.onComplete();\r\n                    valueTransition.onComplete && valueTransition.onComplete();\r\n                },\r\n            });\r\n    }\r\n    function set() {\r\n        const finalTarget = resolveFinalValueInKeyframes(target);\r\n        value.set(finalTarget);\r\n        onComplete();\r\n        valueTransition.onUpdate && valueTransition.onUpdate(finalTarget);\r\n        valueTransition.onComplete && valueTransition.onComplete();\r\n        return { stop: () => { } };\r\n    }\r\n    return !isOriginAnimatable ||\r\n        !isTargetAnimatable ||\r\n        valueTransition.type === false\r\n        ? set\r\n        : start;\r\n}\r\nfunction isZero(value) {\r\n    return (value === 0 ||\r\n        (typeof value === \"string\" &&\r\n            parseFloat(value) === 0 &&\r\n            value.indexOf(\" \") === -1));\r\n}\r\nfunction getZeroUnit(potentialUnitType) {\r\n    return typeof potentialUnitType === \"number\"\r\n        ? 0\r\n        : getAnimatableNone(\"\", potentialUnitType);\r\n}\r\nfunction getValueTransition(transition, key) {\r\n    return transition[key] || transition[\"default\"] || transition;\r\n}\r\n/**\r\n * Start animation on a MotionValue. This function is an interface between\r\n * Framer Motion and Popmotion\r\n */\r\nfunction startAnimation(key, value, target, transition = {}) {\r\n    if (instantAnimationState.current) {\r\n        transition = { type: false };\r\n    }\r\n    return value.start((onComplete) => {\r\n        let controls;\r\n        const animation = getAnimation(key, value, target, transition, onComplete);\r\n        const delayBy = getDelayFromTransition(transition, key);\r\n        const start = () => (controls = animation());\r\n        let cancelDelay;\r\n        if (delayBy) {\r\n            cancelDelay = delay(start, secondsToMilliseconds(delayBy));\r\n        }\r\n        else {\r\n            start();\r\n        }\r\n        return () => {\r\n            cancelDelay && cancelDelay();\r\n            controls && controls.stop();\r\n        };\r\n    });\r\n}\r\n\r\nexport { convertTransitionToAnimationOptions, getDelayFromTransition, getPopmotionAnimationOptions, getValueTransition, getZeroUnit, hydrateKeyframes, isTransitionDefined, isZero, startAnimation };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}