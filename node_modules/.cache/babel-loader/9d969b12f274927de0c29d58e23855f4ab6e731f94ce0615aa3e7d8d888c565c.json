{"ast":null,"code":"import { keyframes } from './keyframes.mjs';\nimport { spring } from './spring.mjs';\nimport { decay } from './decay.mjs';\nimport sync, { cancelSync } from 'framesync';\nimport { interpolate } from '../../utils/interpolate.mjs';\nconst types = {\n  decay,\n  keyframes,\n  spring\n};\nfunction loopElapsed(elapsed, duration) {\n  let delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return elapsed - duration - delay;\n}\nfunction reverseElapsed(elapsed) {\n  let duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let isForwardPlayback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n  return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\nconst framesync = update => {\n  const passTimestamp = _ref => {\n    let {\n      delta\n    } = _ref;\n    return update(delta);\n  };\n  return {\n    start: () => sync.update(passTimestamp, true),\n    stop: () => cancelSync.update(passTimestamp)\n  };\n};\nfunction animate(_ref2) {\n  let {\n    from,\n    autoplay = true,\n    driver = framesync,\n    elapsed = 0,\n    repeat: repeatMax = 0,\n    repeatType = \"loop\",\n    repeatDelay = 0,\n    onPlay,\n    onStop,\n    onComplete,\n    onRepeat,\n    onUpdate,\n    type = \"keyframes\",\n    ...options\n  } = _ref2;\n  var _a, _b;\n  let {\n    to\n  } = options;\n  let driverControls;\n  let repeatCount = 0;\n  let computedDuration = options.duration;\n  let latest;\n  let isComplete = false;\n  let isForwardPlayback = true;\n  let interpolateFromNumber;\n  const animator = types[Array.isArray(to) ? \"keyframes\" : type];\n  if ((_b = (_a = animator).needsInterpolation) === null || _b === void 0 ? void 0 : _b.call(_a, from, to)) {\n    interpolateFromNumber = interpolate([0, 100], [from, to], {\n      clamp: false\n    });\n    from = 0;\n    to = 100;\n  }\n  const animation = animator({\n    ...options,\n    from,\n    to\n  });\n  function repeat() {\n    repeatCount++;\n    if (repeatType === \"reverse\") {\n      isForwardPlayback = repeatCount % 2 === 0;\n      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n    } else {\n      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n      if (repeatType === \"mirror\") animation.flipTarget();\n    }\n    isComplete = false;\n    onRepeat && onRepeat();\n  }\n  function complete() {\n    driverControls.stop();\n    onComplete && onComplete();\n  }\n  function update(delta) {\n    if (!isForwardPlayback) delta = -delta;\n    elapsed += delta;\n    if (!isComplete) {\n      const state = animation.next(Math.max(0, elapsed));\n      latest = state.value;\n      if (interpolateFromNumber) latest = interpolateFromNumber(latest);\n      isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n    }\n    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\n    if (isComplete) {\n      if (repeatCount === 0) computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;\n      if (repeatCount < repeatMax) {\n        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n      } else {\n        complete();\n      }\n    }\n  }\n  function play() {\n    onPlay === null || onPlay === void 0 ? void 0 : onPlay();\n    driverControls = driver(update);\n    driverControls.start();\n  }\n  autoplay && play();\n  return {\n    stop: () => {\n      onStop === null || onStop === void 0 ? void 0 : onStop();\n      driverControls.stop();\n    }\n  };\n}\nexport { animate, hasRepeatDelayElapsed, loopElapsed, reverseElapsed };","map":{"version":3,"names":["keyframes","spring","decay","sync","cancelSync","interpolate","types","loopElapsed","elapsed","duration","delay","reverseElapsed","isForwardPlayback","hasRepeatDelayElapsed","framesync","update","passTimestamp","delta","start","stop","animate","from","autoplay","driver","repeat","repeatMax","repeatType","repeatDelay","onPlay","onStop","onComplete","onRepeat","onUpdate","type","options","_a","_b","to","driverControls","repeatCount","computedDuration","latest","isComplete","interpolateFromNumber","animator","Array","isArray","needsInterpolation","call","clamp","animation","flipTarget","complete","state","next","Math","max","value","done","play"],"sources":["R:/Projects/Trivia-Maximus/node_modules/framer-motion/dist/es/animation/legacy-popmotion/index.mjs"],"sourcesContent":["import { keyframes } from './keyframes.mjs';\r\nimport { spring } from './spring.mjs';\r\nimport { decay } from './decay.mjs';\r\nimport sync, { cancelSync } from 'framesync';\r\nimport { interpolate } from '../../utils/interpolate.mjs';\r\n\r\nconst types = { decay, keyframes, spring };\r\nfunction loopElapsed(elapsed, duration, delay = 0) {\r\n    return elapsed - duration - delay;\r\n}\r\nfunction reverseElapsed(elapsed, duration = 0, delay = 0, isForwardPlayback = true) {\r\n    return isForwardPlayback\r\n        ? loopElapsed(duration + -elapsed, duration, delay)\r\n        : duration - (elapsed - duration) + delay;\r\n}\r\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\r\n    return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\r\n}\r\nconst framesync = (update) => {\r\n    const passTimestamp = ({ delta }) => update(delta);\r\n    return {\r\n        start: () => sync.update(passTimestamp, true),\r\n        stop: () => cancelSync.update(passTimestamp),\r\n    };\r\n};\r\nfunction animate({ from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = \"loop\", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate, type = \"keyframes\", ...options }) {\r\n    var _a, _b;\r\n    let { to } = options;\r\n    let driverControls;\r\n    let repeatCount = 0;\r\n    let computedDuration = options\r\n        .duration;\r\n    let latest;\r\n    let isComplete = false;\r\n    let isForwardPlayback = true;\r\n    let interpolateFromNumber;\r\n    const animator = types[Array.isArray(to) ? \"keyframes\" : type];\r\n    if ((_b = (_a = animator).needsInterpolation) === null || _b === void 0 ? void 0 : _b.call(_a, from, to)) {\r\n        interpolateFromNumber = interpolate([0, 100], [from, to], {\r\n            clamp: false,\r\n        });\r\n        from = 0;\r\n        to = 100;\r\n    }\r\n    const animation = animator({ ...options, from, to });\r\n    function repeat() {\r\n        repeatCount++;\r\n        if (repeatType === \"reverse\") {\r\n            isForwardPlayback = repeatCount % 2 === 0;\r\n            elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\r\n        }\r\n        else {\r\n            elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\r\n            if (repeatType === \"mirror\")\r\n                animation.flipTarget();\r\n        }\r\n        isComplete = false;\r\n        onRepeat && onRepeat();\r\n    }\r\n    function complete() {\r\n        driverControls.stop();\r\n        onComplete && onComplete();\r\n    }\r\n    function update(delta) {\r\n        if (!isForwardPlayback)\r\n            delta = -delta;\r\n        elapsed += delta;\r\n        if (!isComplete) {\r\n            const state = animation.next(Math.max(0, elapsed));\r\n            latest = state.value;\r\n            if (interpolateFromNumber)\r\n                latest = interpolateFromNumber(latest);\r\n            isComplete = isForwardPlayback ? state.done : elapsed <= 0;\r\n        }\r\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\r\n        if (isComplete) {\r\n            if (repeatCount === 0)\r\n                computedDuration !== null && computedDuration !== void 0 ? computedDuration : (computedDuration = elapsed);\r\n            if (repeatCount < repeatMax) {\r\n                hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\r\n            }\r\n            else {\r\n                complete();\r\n            }\r\n        }\r\n    }\r\n    function play() {\r\n        onPlay === null || onPlay === void 0 ? void 0 : onPlay();\r\n        driverControls = driver(update);\r\n        driverControls.start();\r\n    }\r\n    autoplay && play();\r\n    return {\r\n        stop: () => {\r\n            onStop === null || onStop === void 0 ? void 0 : onStop();\r\n            driverControls.stop();\r\n        },\r\n    };\r\n}\r\n\r\nexport { animate, hasRepeatDelayElapsed, loopElapsed, reverseElapsed };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}