{"ast":null,"code":"import { complex } from 'style-value-types';\nimport { cssVariableRegex } from '../../render/dom/utils/css-variables-conversion.mjs';\nimport { mix } from '../../utils/mix.mjs';\nvar varToken = \"_$css\";\nvar correctBoxShadow = {\n  correct: function correct(latest, _ref) {\n    var treeScale = _ref.treeScale,\n      projectionDelta = _ref.projectionDelta;\n    var original = latest;\n    /**\r\n     * We need to first strip and store CSS variables from the string.\r\n     */\n    var containsCSSVariables = latest.includes(\"var(\");\n    var cssVariables = [];\n    if (containsCSSVariables) {\n      latest = latest.replace(cssVariableRegex, function (match) {\n        cssVariables.push(match);\n        return varToken;\n      });\n    }\n    var shadow = complex.parse(latest);\n    // TODO: Doesn't support multiple shadows\n    if (shadow.length > 5) return original;\n    var template = complex.createTransformer(latest);\n    var offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n    // Calculate the overall context scale\n    var xScale = projectionDelta.x.scale * treeScale.x;\n    var yScale = projectionDelta.y.scale * treeScale.y;\n    shadow[0 + offset] /= xScale;\n    shadow[1 + offset] /= yScale;\n    /**\r\n     * Ideally we'd correct x and y scales individually, but because blur and\r\n     * spread apply to both we have to take a scale average and apply that instead.\r\n     * We could potentially improve the outcome of this by incorporating the ratio between\r\n     * the two scales.\r\n     */\n    var averageScale = mix(xScale, yScale, 0.5);\n    // Blur\n    if (typeof shadow[2 + offset] === \"number\") shadow[2 + offset] /= averageScale;\n    // Spread\n    if (typeof shadow[3 + offset] === \"number\") shadow[3 + offset] /= averageScale;\n    var output = template(shadow);\n    if (containsCSSVariables) {\n      var i = 0;\n      output = output.replace(varToken, function () {\n        var cssVariable = cssVariables[i];\n        i++;\n        return cssVariable;\n      });\n    }\n    return output;\n  }\n};\nexport { correctBoxShadow };","map":{"version":3,"names":["complex","cssVariableRegex","mix","varToken","correctBoxShadow","correct","latest","treeScale","projectionDelta","original","containsCSSVariables","includes","cssVariables","replace","match","push","shadow","parse","length","template","createTransformer","offset","xScale","x","scale","yScale","y","averageScale","output","i","cssVariable"],"sources":["R:/Projects/Trivia-Maximus/node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs"],"sourcesContent":["import { complex } from 'style-value-types';\r\nimport { cssVariableRegex } from '../../render/dom/utils/css-variables-conversion.mjs';\r\nimport { mix } from '../../utils/mix.mjs';\r\n\r\nconst varToken = \"_$css\";\r\nconst correctBoxShadow = {\r\n    correct: (latest, { treeScale, projectionDelta }) => {\r\n        const original = latest;\r\n        /**\r\n         * We need to first strip and store CSS variables from the string.\r\n         */\r\n        const containsCSSVariables = latest.includes(\"var(\");\r\n        const cssVariables = [];\r\n        if (containsCSSVariables) {\r\n            latest = latest.replace(cssVariableRegex, (match) => {\r\n                cssVariables.push(match);\r\n                return varToken;\r\n            });\r\n        }\r\n        const shadow = complex.parse(latest);\r\n        // TODO: Doesn't support multiple shadows\r\n        if (shadow.length > 5)\r\n            return original;\r\n        const template = complex.createTransformer(latest);\r\n        const offset = typeof shadow[0] !== \"number\" ? 1 : 0;\r\n        // Calculate the overall context scale\r\n        const xScale = projectionDelta.x.scale * treeScale.x;\r\n        const yScale = projectionDelta.y.scale * treeScale.y;\r\n        shadow[0 + offset] /= xScale;\r\n        shadow[1 + offset] /= yScale;\r\n        /**\r\n         * Ideally we'd correct x and y scales individually, but because blur and\r\n         * spread apply to both we have to take a scale average and apply that instead.\r\n         * We could potentially improve the outcome of this by incorporating the ratio between\r\n         * the two scales.\r\n         */\r\n        const averageScale = mix(xScale, yScale, 0.5);\r\n        // Blur\r\n        if (typeof shadow[2 + offset] === \"number\")\r\n            shadow[2 + offset] /= averageScale;\r\n        // Spread\r\n        if (typeof shadow[3 + offset] === \"number\")\r\n            shadow[3 + offset] /= averageScale;\r\n        let output = template(shadow);\r\n        if (containsCSSVariables) {\r\n            let i = 0;\r\n            output = output.replace(varToken, () => {\r\n                const cssVariable = cssVariables[i];\r\n                i++;\r\n                return cssVariable;\r\n            });\r\n        }\r\n        return output;\r\n    },\r\n};\r\n\r\nexport { correctBoxShadow };\r\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,mBAAmB;AAC3C,SAASC,gBAAgB,QAAQ,qDAAqD;AACtF,SAASC,GAAG,QAAQ,qBAAqB;AAEzC,IAAMC,QAAQ,GAAG,OAAO;AACxB,IAAMC,gBAAgB,GAAG;EACrBC,OAAO,EAAE,iBAACC,MAAM,QAAqC;IAAA,IAAjCC,SAAS,QAATA,SAAS;MAAEC,eAAe,QAAfA,eAAe;IAC1C,IAAMC,QAAQ,GAAGH,MAAM;IACvB;AACR;AACA;IACQ,IAAMI,oBAAoB,GAAGJ,MAAM,CAACK,QAAQ,CAAC,MAAM,CAAC;IACpD,IAAMC,YAAY,GAAG,EAAE;IACvB,IAAIF,oBAAoB,EAAE;MACtBJ,MAAM,GAAGA,MAAM,CAACO,OAAO,CAACZ,gBAAgB,EAAE,UAACa,KAAK,EAAK;QACjDF,YAAY,CAACG,IAAI,CAACD,KAAK,CAAC;QACxB,OAAOX,QAAQ;MACnB,CAAC,CAAC;IACN;IACA,IAAMa,MAAM,GAAGhB,OAAO,CAACiB,KAAK,CAACX,MAAM,CAAC;IACpC;IACA,IAAIU,MAAM,CAACE,MAAM,GAAG,CAAC,EACjB,OAAOT,QAAQ;IACnB,IAAMU,QAAQ,GAAGnB,OAAO,CAACoB,iBAAiB,CAACd,MAAM,CAAC;IAClD,IAAMe,MAAM,GAAG,OAAOL,MAAM,CAAC,CAAC,CAAC,KAAK,QAAQ,GAAG,CAAC,GAAG,CAAC;IACpD;IACA,IAAMM,MAAM,GAAGd,eAAe,CAACe,CAAC,CAACC,KAAK,GAAGjB,SAAS,CAACgB,CAAC;IACpD,IAAME,MAAM,GAAGjB,eAAe,CAACkB,CAAC,CAACF,KAAK,GAAGjB,SAAS,CAACmB,CAAC;IACpDV,MAAM,CAAC,CAAC,GAAGK,MAAM,CAAC,IAAIC,MAAM;IAC5BN,MAAM,CAAC,CAAC,GAAGK,MAAM,CAAC,IAAII,MAAM;IAC5B;AACR;AACA;AACA;AACA;AACA;IACQ,IAAME,YAAY,GAAGzB,GAAG,CAACoB,MAAM,EAAEG,MAAM,EAAE,GAAG,CAAC;IAC7C;IACA,IAAI,OAAOT,MAAM,CAAC,CAAC,GAAGK,MAAM,CAAC,KAAK,QAAQ,EACtCL,MAAM,CAAC,CAAC,GAAGK,MAAM,CAAC,IAAIM,YAAY;IACtC;IACA,IAAI,OAAOX,MAAM,CAAC,CAAC,GAAGK,MAAM,CAAC,KAAK,QAAQ,EACtCL,MAAM,CAAC,CAAC,GAAGK,MAAM,CAAC,IAAIM,YAAY;IACtC,IAAIC,MAAM,GAAGT,QAAQ,CAACH,MAAM,CAAC;IAC7B,IAAIN,oBAAoB,EAAE;MACtB,IAAImB,CAAC,GAAG,CAAC;MACTD,MAAM,GAAGA,MAAM,CAACf,OAAO,CAACV,QAAQ,EAAE,YAAM;QACpC,IAAM2B,WAAW,GAAGlB,YAAY,CAACiB,CAAC,CAAC;QACnCA,CAAC,EAAE;QACH,OAAOC,WAAW;MACtB,CAAC,CAAC;IACN;IACA,OAAOF,MAAM;EACjB;AACJ,CAAC;AAED,SAASxB,gBAAgB"},"metadata":{},"sourceType":"module","externalDependencies":[]}