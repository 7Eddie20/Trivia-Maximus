{"ast":null,"code":"import _objectWithoutProperties from \"R:/Projects/Trivia-Maximus/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"R:/Projects/Trivia-Maximus/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _excluded = [\"from\", \"to\", \"restSpeed\", \"restDelta\"];\nimport { findSpring, calcAngularFreq } from './find-spring.mjs';\nvar durationKeys = [\"duration\", \"bounce\"];\nvar physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n  return keys.some(function (key) {\n    return options[key] !== undefined;\n  });\n}\nfunction getSpringOptions(options) {\n  var springOptions = _objectSpread({\n    velocity: 0.0,\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    isResolvedFromDuration: false\n  }, options);\n  // stiffness/damping/mass overrides duration/bounce\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    var derived = findSpring(options);\n    springOptions = _objectSpread(_objectSpread(_objectSpread({}, springOptions), derived), {}, {\n      velocity: 0.0,\n      mass: 1.0\n    });\n    springOptions.isResolvedFromDuration = true;\n  }\n  return springOptions;\n}\n/**\r\n * This is based on the spring implementation of Wobble https://github.com/skevy/wobble\r\n */\nfunction spring(_ref) {\n  var _ref$from = _ref.from,\n    from = _ref$from === void 0 ? 0.0 : _ref$from,\n    _ref$to = _ref.to,\n    to = _ref$to === void 0 ? 1.0 : _ref$to,\n    _ref$restSpeed = _ref.restSpeed,\n    restSpeed = _ref$restSpeed === void 0 ? 2 : _ref$restSpeed,\n    _ref$restDelta = _ref.restDelta,\n    restDelta = _ref$restDelta === void 0 ? 0.01 : _ref$restDelta,\n    options = _objectWithoutProperties(_ref, _excluded);\n  /**\r\n   * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\r\n   * to reduce GC during animation.\r\n   */\n  var state = {\n    done: false,\n    value: from\n  };\n  var _getSpringOptions = getSpringOptions(options),\n    stiffness = _getSpringOptions.stiffness,\n    damping = _getSpringOptions.damping,\n    mass = _getSpringOptions.mass,\n    velocity = _getSpringOptions.velocity,\n    duration = _getSpringOptions.duration,\n    isResolvedFromDuration = _getSpringOptions.isResolvedFromDuration;\n  var resolveSpring = zero;\n  var resolveVelocity = zero;\n  function createSpring() {\n    var initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n    var initialDelta = to - from;\n    var dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    var undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n    /**\r\n     * If we're working within what looks like a 0-1 range, change the default restDelta\r\n     * to 0.01\r\n     */\n    if (restDelta === undefined) {\n      restDelta = Math.min(Math.abs(to - from) / 100, 0.4);\n    }\n    if (dampingRatio < 1) {\n      var angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n      // Underdamped spring\n      resolveSpring = function resolveSpring(t) {\n        var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n      };\n      resolveVelocity = function resolveVelocity(t) {\n        // TODO Resolve these calculations with the above\n        var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t)) - envelope * (Math.cos(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t));\n      };\n    } else if (dampingRatio === 1) {\n      // Critically damped spring\n      resolveSpring = function resolveSpring(t) {\n        return to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n      };\n    } else {\n      // Overdamped spring\n      var dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n      resolveSpring = function resolveSpring(t) {\n        var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        // When performing sinh or cosh values can hit Infinity so we cap them here\n        var freqForT = Math.min(dampedAngularFreq * t, 300);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n      };\n    }\n  }\n  createSpring();\n  return {\n    next: function next(t) {\n      var current = resolveSpring(t);\n      if (!isResolvedFromDuration) {\n        var currentVelocity = resolveVelocity(t) * 1000;\n        var isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        var isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n      state.value = state.done ? to : current;\n      return state;\n    },\n    flipTarget: function flipTarget() {\n      velocity = -velocity;\n      var _ref2 = [to, from];\n      from = _ref2[0];\n      to = _ref2[1];\n      createSpring();\n    }\n  };\n}\nspring.needsInterpolation = function (a, b) {\n  return typeof a === \"string\" || typeof b === \"string\";\n};\nvar zero = function zero(_t) {\n  return 0;\n};\nexport { spring };","map":{"version":3,"names":["findSpring","calcAngularFreq","durationKeys","physicsKeys","isSpringType","options","keys","some","key","undefined","getSpringOptions","springOptions","velocity","stiffness","damping","mass","isResolvedFromDuration","derived","spring","from","to","restSpeed","restDelta","state","done","value","duration","resolveSpring","zero","resolveVelocity","createSpring","initialVelocity","initialDelta","dampingRatio","Math","sqrt","undampedAngularFreq","min","abs","angularFreq","t","envelope","exp","sin","cos","dampedAngularFreq","freqForT","sinh","cosh","next","current","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","flipTarget","needsInterpolation","a","b","_t"],"sources":["R:/Projects/Trivia-Maximus/node_modules/framer-motion/dist/es/animation/legacy-popmotion/spring.mjs"],"sourcesContent":["import { findSpring, calcAngularFreq } from './find-spring.mjs';\r\n\r\nconst durationKeys = [\"duration\", \"bounce\"];\r\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\r\nfunction isSpringType(options, keys) {\r\n    return keys.some((key) => options[key] !== undefined);\r\n}\r\nfunction getSpringOptions(options) {\r\n    let springOptions = {\r\n        velocity: 0.0,\r\n        stiffness: 100,\r\n        damping: 10,\r\n        mass: 1.0,\r\n        isResolvedFromDuration: false,\r\n        ...options,\r\n    };\r\n    // stiffness/damping/mass overrides duration/bounce\r\n    if (!isSpringType(options, physicsKeys) &&\r\n        isSpringType(options, durationKeys)) {\r\n        const derived = findSpring(options);\r\n        springOptions = {\r\n            ...springOptions,\r\n            ...derived,\r\n            velocity: 0.0,\r\n            mass: 1.0,\r\n        };\r\n        springOptions.isResolvedFromDuration = true;\r\n    }\r\n    return springOptions;\r\n}\r\n/**\r\n * This is based on the spring implementation of Wobble https://github.com/skevy/wobble\r\n */\r\nfunction spring({ from = 0.0, to = 1.0, restSpeed = 2, restDelta = 0.01, ...options }) {\r\n    /**\r\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\r\n     * to reduce GC during animation.\r\n     */\r\n    const state = { done: false, value: from };\r\n    let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration, } = getSpringOptions(options);\r\n    let resolveSpring = zero;\r\n    let resolveVelocity = zero;\r\n    function createSpring() {\r\n        const initialVelocity = velocity ? -(velocity / 1000) : 0.0;\r\n        const initialDelta = to - from;\r\n        const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\r\n        const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\r\n        /**\r\n         * If we're working within what looks like a 0-1 range, change the default restDelta\r\n         * to 0.01\r\n         */\r\n        if (restDelta === undefined) {\r\n            restDelta = Math.min(Math.abs(to - from) / 100, 0.4);\r\n        }\r\n        if (dampingRatio < 1) {\r\n            const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\r\n            // Underdamped spring\r\n            resolveSpring = (t) => {\r\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\r\n                return (to -\r\n                    envelope *\r\n                        (((initialVelocity +\r\n                            dampingRatio * undampedAngularFreq * initialDelta) /\r\n                            angularFreq) *\r\n                            Math.sin(angularFreq * t) +\r\n                            initialDelta * Math.cos(angularFreq * t)));\r\n            };\r\n            resolveVelocity = (t) => {\r\n                // TODO Resolve these calculations with the above\r\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\r\n                return (dampingRatio *\r\n                    undampedAngularFreq *\r\n                    envelope *\r\n                    ((Math.sin(angularFreq * t) *\r\n                        (initialVelocity +\r\n                            dampingRatio *\r\n                                undampedAngularFreq *\r\n                                initialDelta)) /\r\n                        angularFreq +\r\n                        initialDelta * Math.cos(angularFreq * t)) -\r\n                    envelope *\r\n                        (Math.cos(angularFreq * t) *\r\n                            (initialVelocity +\r\n                                dampingRatio *\r\n                                    undampedAngularFreq *\r\n                                    initialDelta) -\r\n                            angularFreq *\r\n                                initialDelta *\r\n                                Math.sin(angularFreq * t)));\r\n            };\r\n        }\r\n        else if (dampingRatio === 1) {\r\n            // Critically damped spring\r\n            resolveSpring = (t) => to -\r\n                Math.exp(-undampedAngularFreq * t) *\r\n                    (initialDelta +\r\n                        (initialVelocity + undampedAngularFreq * initialDelta) *\r\n                            t);\r\n        }\r\n        else {\r\n            // Overdamped spring\r\n            const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\r\n            resolveSpring = (t) => {\r\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\r\n                // When performing sinh or cosh values can hit Infinity so we cap them here\r\n                const freqForT = Math.min(dampedAngularFreq * t, 300);\r\n                return (to -\r\n                    (envelope *\r\n                        ((initialVelocity +\r\n                            dampingRatio * undampedAngularFreq * initialDelta) *\r\n                            Math.sinh(freqForT) +\r\n                            dampedAngularFreq *\r\n                                initialDelta *\r\n                                Math.cosh(freqForT))) /\r\n                        dampedAngularFreq);\r\n            };\r\n        }\r\n    }\r\n    createSpring();\r\n    return {\r\n        next: (t) => {\r\n            const current = resolveSpring(t);\r\n            if (!isResolvedFromDuration) {\r\n                const currentVelocity = resolveVelocity(t) * 1000;\r\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\r\n                const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\r\n                state.done =\r\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\r\n            }\r\n            else {\r\n                state.done = t >= duration;\r\n            }\r\n            state.value = state.done ? to : current;\r\n            return state;\r\n        },\r\n        flipTarget: () => {\r\n            velocity = -velocity;\r\n            [from, to] = [to, from];\r\n            createSpring();\r\n        },\r\n    };\r\n}\r\nspring.needsInterpolation = (a, b) => typeof a === \"string\" || typeof b === \"string\";\r\nconst zero = (_t) => 0;\r\n\r\nexport { spring };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}